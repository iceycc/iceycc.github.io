(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{513:function(s,v,t){"use strict";t.r(v);var _=t(1),r=Object(_.a)({},(function(){var s=this,v=s._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("blockquote",[v("p",[s._v("当你发现自己的才华撑不起你的野心时，就请安静下来学习吧！")])]),s._v(" "),v("p",[v("img",{attrs:{src:"https://image.icey.cc/3+2.png",alt:""}})]),s._v(" "),v("blockquote",[v("p",[s._v("鲁迅说过："),v("code",[s._v("答案仅供参考...")])])]),s._v(" "),v("h2",{attrs:{id:"_1、介绍一下你对浏览器内核的理解-常见的浏览器内核有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、介绍一下你对浏览器内核的理解-常见的浏览器内核有哪些"}},[s._v("#")]),s._v(" 1、介绍一下你对浏览器内核的理解？常见的浏览器内核有哪些？")]),s._v(" "),v("p",[s._v("解析：")]),s._v(" "),v("p",[s._v("浏览器内核分渲染引擎（rendering engine）和Js引擎,其中最主要对就是渲染引擎。由于js渲染引擎越来也独立，浏览器内核更倾向于指的是渲染引擎。"),v("br"),s._v("\n渲染引擎的作用：对html文档和css样式进行解析，并在页面中渲染出来。"),v("br"),s._v("\n浏览器构成：渲染引擎(html解析，css解析，布局layout解析。。) + js引擎（现在已经独立）+ 网络 + 存储 + 音频视频 + 图片解析器 等 => 浏览器\n常见")]),s._v(" "),v("h2",{attrs:{id:"_2、css3有哪些新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、css3有哪些新特性"}},[s._v("#")]),s._v(" 2、css3有哪些新特性？")]),s._v(" "),v("p",[s._v("解析：")]),s._v(" "),v("ul",[v("li",[s._v("CSS3选择器：一堆")]),s._v(" "),v("li",[s._v("css3边框 borders")]),s._v(" "),v("li",[s._v("css3背景 / 背景裁切 / 多背景")]),s._v(" "),v("li",[s._v("css3渐变")]),s._v(" "),v("li",[s._v("css3文本效果")]),s._v(" "),v("li",[s._v("css3字体：@font-face")]),s._v(" "),v("li",[s._v("css3转换和变形：2D 3D transform")]),s._v(" "),v("li",[s._v("css3过渡 transition")]),s._v(" "),v("li",[s._v("css3动画 @keyframes /  animation")]),s._v(" "),v("li",[s._v("css3多列 columns")]),s._v(" "),v("li",[s._v("css3 盒模型 增加内外边框等")]),s._v(" "),v("li",[s._v("css3 弹性盒子 flex box")]),s._v(" "),v("li",[s._v("css3 媒体查询 @media all and (min-width: 800px) { ... }")])]),s._v(" "),v("h2",{attrs:{id:"_3、传统布局和flex布局的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、传统布局和flex布局的区别"}},[s._v("#")]),s._v(" 3、传统布局和flex布局的区别？")]),s._v(" "),v("p",[s._v("解析：")]),s._v(" "),v("p",[s._v("传统布局：基于盒模型，依赖 display、position、float"),v("br"),s._v("\nflex布局："),v("br"),s._v("\n父盒子设置 display: flex，flex-direction ，控制子盒子的排布方向、对齐方式。"),v("br"),s._v("\n子盒子自身控制比例，响应式，排布顺序等"),v("br"),s._v("\n距离具体描述")]),s._v(" "),v("h2",{attrs:{id:"_4、vue的数据双向绑定是怎么实现的-详细描述什么时候监听变化-什么时候发生变化-此处简述vue2的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、vue的数据双向绑定是怎么实现的-详细描述什么时候监听变化-什么时候发生变化-此处简述vue2的原理"}},[s._v("#")]),s._v(" 4、vue的数据双向绑定是怎么实现的，详细描述什么时候监听变化?什么时候发生变化？（此处简述vue2的原理）")]),s._v(" "),v("p",[s._v("解析："),v("br"),s._v(" "),v("a",{attrs:{href:"https://github.com/canfoo/self-vue",target:"_blank",rel:"noopener noreferrer"}},[s._v("href"),v("OutboundLink")],1),s._v("\nVue双向数据绑定： 双向数据绑定无非就是在单向数据绑定的基础上给可输入元素，比如input和textarea添加监听事件来动态修改model和view，其最核心的方法就是通过Object.defineProperty()来实现对对属性的劫持，达到监听数据变化的目的。 要实现mvvm双向数据版绑定， 我觉得需要实现以下几点：")]),s._v(" "),v("ol",[v("li",[s._v("实现一个数据监听器Observer,能够对数据对象的所有属性进行监听，如有变动可以拿到最新值并通知订阅者")]),s._v(" "),v("li",[s._v("实现一个指令解析器Compiler，对每个元素节点的指令扫描并解析，根据指令模板替换数据，并且绑定相应的更新函数。")]),s._v(" "),v("li",[s._v("实现一个watcher，其作为连接Observer和Compiler的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的回调函数从而更新视图 4.MVVM作为入口函数，整个以上三者")])]),s._v(" "),v("h2",{attrs:{id:"_5、比较两个颜色的相似度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、比较两个颜色的相似度"}},[s._v("#")]),s._v(" 5、比较两个颜色的相似度：")]),s._v(" "),v("blockquote",[v("p",[s._v("这是一道开放题目，首先将颜色拆分成r/g/b三个值，如果是字符串的颜色如#aabbff或者rgb(255,128,100)可以用正则表达式取出对应的r/g/b值。对于16进制字符串，可以使用parseInt('0xaa')转10进制整数。然后对于两个颜色，可以使用距离 Math.sqrt( (r1-r2) (r1-r2) +(g1-g2)(g1-g2)+(b1-b2)*(b1-b2) )进行比较， 距离近则相似。 当然可以用Math.hypot( r1-r2, g1-t2, b1-b2) 来简化上述运算。 这道题目主要考察学员的知识积累和思考。 首先要知道rgb是颜色的组成。 然后要给出一种可行的比较方法。 最后要考察具体javascript细节函数的运用")])]),s._v(" "),v("p",[s._v("解析：")])])}),[],!1,null,null,null);v.default=r.exports}}]);