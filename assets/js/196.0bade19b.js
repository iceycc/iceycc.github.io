(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{629:function(t,a,e){"use strict";e.r(a);var v=e(1),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-谈一下你对mvvm的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-谈一下你对mvvm的理解"}},[t._v("#")]),t._v(" 1. 谈一下你对mvvm的理解？")]),t._v(" "),a("h2",{attrs:{id:"_2-请说一下响应式数据的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-请说一下响应式数据的原理"}},[t._v("#")]),t._v(" 2. 请说一下响应式数据的原理?")]),t._v(" "),a("h2",{attrs:{id:"_3-vue中是如何检测数组变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue中是如何检测数组变化"}},[t._v("#")]),t._v(" 3. vue中是如何检测数组变化?")]),t._v(" "),a("h2",{attrs:{id:"_4-为何vue采用异步渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-为何vue采用异步渲染"}},[t._v("#")]),t._v(" 4. 为何vue采用异步渲染?")]),t._v(" "),a("ul",[a("li",[t._v("因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染.所以为了性能考虑。 Vue 会在本轮数据更新后，再去异步更新视图!")])]),t._v(" "),a("h2",{attrs:{id:"_5-nexttick实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-nexttick实现原理"}},[t._v("#")]),t._v(" 5. nextTick实现原理?")]),t._v(" "),a("ul",[a("li",[t._v("nextTick方法主要是使用了宏任务和微任务,定义了一个异步方法.多次调用nextTick 会将方法存入 队列中，通过这个异步方法清空当前队列。 所以这个 nextTick 方法就是异步方法")])]),t._v(" "),a("h2",{attrs:{id:"_6-vue中computed的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue中computed的特点"}},[t._v("#")]),t._v(" 6. vue中computed的特点")]),t._v(" "),a("ul",[a("li",[t._v("默认 也是一个 是具备缓存的，只要当依赖的属性发生变化时才会更新视图")])]),t._v(" "),a("h2",{attrs:{id:"_7-watch中的deep-true-是如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-watch中的deep-true-是如何实现的"}},[t._v("#")]),t._v(" 7. "),a("code",[t._v("watch")]),t._v("中的"),a("code",[t._v("deep:true")]),t._v(" 是如何实现的")]),t._v(" "),a("h2",{attrs:{id:"_8-vue组件的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue组件的生命周期"}},[t._v("#")]),t._v(" 8. vue组件的生命周期")]),t._v(" "),a("ul",[a("li",[t._v("每个生命周期什么时候调用的")]),t._v(" "),a("li",[t._v("每个生命周期内可以做什么事情")])]),t._v(" "),a("h2",{attrs:{id:"_9-ajax放在那个生命周期内"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-ajax放在那个生命周期内"}},[t._v("#")]),t._v(" 9. ajax放在那个生命周期内？")]),t._v(" "),a("ul",[a("li",[t._v("在created的时候，视图中的 dom 并没有渲染出来，所以此时如果直接去操 dom 节点，无法找到相 关的元素")]),t._v(" "),a("li",[t._v("在mounted中，由于此时 dom 已经渲染出来了，所以可以直接操作 dom 节点")]),t._v(" "),a("li",[t._v("一般情况下都放到 mounted 中,保证逻辑的统一性,因为生命周期是同步执行的， ajax 是异步执行的")]),t._v(" "),a("li",[t._v("服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放到created中")])]),t._v(" "),a("h2",{attrs:{id:"_10-合适调用beforedestroy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-合适调用beforedestroy"}},[t._v("#")]),t._v(" 10. 合适调用beforeDestroy？")]),t._v(" "),a("ul",[a("li",[t._v("可能在当前页面中使用了 $on 方法，那需要在组件销毁前解绑。")]),t._v(" "),a("li",[t._v("清除自己定义的定时器")]),t._v(" "),a("li",[t._v("解除事件的绑定 scroll mousemove ....")])]),t._v(" "),a("h2",{attrs:{id:"_11-vue中模版编译的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue中模版编译的原理"}},[t._v("#")]),t._v(" 11. vue中模版编译的原理")]),t._v(" "),a("h2",{attrs:{id:"_12-vue中v-if和v-show的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue中v-if和v-show的区别"}},[t._v("#")]),t._v(" 12. vue中v-if和v-show的区别")]),t._v(" "),a("h2",{attrs:{id:"_13-为什么v-if和v-for不能连用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-为什么v-if和v-for不能连用"}},[t._v("#")]),t._v(" 13. 为什么v-if和v-for不能连用")]),t._v(" "),a("h2",{attrs:{id:"_14-用vnode来描述一个dom结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-用vnode来描述一个dom结构"}},[t._v("#")]),t._v(" 14. 用vnode来描述一个DOM结构")]),t._v(" "),a("h2",{attrs:{id:"_15-diff算法的时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-diff算法的时间复杂度"}},[t._v("#")]),t._v(" 15. diff算法的时间复杂度")]),t._v(" "),a("h2",{attrs:{id:"_16-简述vue中diff算法原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-简述vue中diff算法原理"}},[t._v("#")]),t._v(" 16. 简述vue中diff算法原理")])])}),[],!1,null,null,null);a.default=_.exports}}]);